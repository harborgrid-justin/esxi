//! Tile pyramid generation for web mapping

use crate::error::{ImageryError, Result};
use crate::MultiBandImage;
use std::path::{Path, PathBuf};

/// Tile pyramid generator
pub struct TilePyramid {
    tile_size: u32,
    min_zoom: u8,
    max_zoom: u8,
    output_dir: PathBuf,
    format: TileFormat,
}

/// Tile format
#[derive(Debug, Clone, Copy)]
pub enum TileFormat {
    /// PNG
    Png,
    /// JPEG
    Jpeg,
    /// WebP
    WebP,
}

impl TilePyramid {
    /// Create a new tile pyramid generator
    pub fn new(output_dir: impl AsRef<Path>) -> Self {
        Self {
            tile_size: 256,
            min_zoom: 0,
            max_zoom: 18,
            output_dir: output_dir.as_ref().to_path_buf(),
            format: TileFormat::Png,
        }
    }

    /// Set tile size
    pub fn with_tile_size(mut self, size: u32) -> Self {
        self.tile_size = size;
        self
    }

    /// Set zoom levels
    pub fn with_zoom_levels(mut self, min: u8, max: u8) -> Self {
        self.min_zoom = min;
        self.max_zoom = max;
        self
    }

    /// Set tile format
    pub fn with_format(mut self, format: TileFormat) -> Self {
        self.format = format;
        self
    }

    /// Generate tile pyramid
    pub fn generate(&self, image: &MultiBandImage) -> Result<TilePyramidInfo> {
        log::info!(
            "Generating tile pyramid: zoom {}-{}, tile size {}",
            self.min_zoom,
            self.max_zoom,
            self.tile_size
        );

        // Create output directory
        std::fs::create_dir_all(&self.output_dir)?;

        let mut total_tiles = 0;

        // Generate tiles for each zoom level
        for zoom in self.min_zoom..=self.max_zoom {
            let tiles_count = self.generate_zoom_level(image, zoom)?;
            total_tiles += tiles_count;
            log::debug!("Zoom level {}: {} tiles", zoom, tiles_count);
        }

        Ok(TilePyramidInfo {
            min_zoom: self.min_zoom,
            max_zoom: self.max_zoom,
            tile_size: self.tile_size,
            total_tiles,
            format: self.format,
        })
    }

    /// Generate tiles for a specific zoom level
    fn generate_zoom_level(&self, image: &MultiBandImage, zoom: u8) -> Result<usize> {
        // Calculate number of tiles at this zoom level
        let scale = 2f64.powi((self.max_zoom - zoom) as i32);
        let scaled_width = (image.metadata.width as f64 / scale) as u32;
        let scaled_height = (image.metadata.height as f64 / scale) as u32;

        let tiles_x = (scaled_width + self.tile_size - 1) / self.tile_size;
        let tiles_y = (scaled_height + self.tile_size - 1) / self.tile_size;

        // Create zoom directory
        let zoom_dir = self.output_dir.join(zoom.to_string());
        std::fs::create_dir_all(&zoom_dir)?;

        let mut count = 0;

        // Generate each tile
        for ty in 0..tiles_y {
            let x_dir = zoom_dir.join(ty.to_string());
            std::fs::create_dir_all(&x_dir)?;

            for tx in 0..tiles_x {
                let tile_path = x_dir.join(format!("{}.{}", tx, self.get_extension()));

                // Calculate tile bounds in original image
                let x = (tx * self.tile_size) as f64 * scale;
                let y = (ty * self.tile_size) as f64 * scale;
                let w = (self.tile_size as f64 * scale).min(image.metadata.width as f64 - x);
                let h = (self.tile_size as f64 * scale).min(image.metadata.height as f64 - y);

                // Extract and save tile
                self.save_tile(image, &tile_path, x as u32, y as u32, w as u32, h as u32)?;

                count += 1;
            }
        }

        Ok(count)
    }

    /// Save a tile
    fn save_tile(
        &self,
        image: &MultiBandImage,
        path: &Path,
        x: u32,
        y: u32,
        width: u32,
        height: u32,
    ) -> Result<()> {
        // Extract tile region
        // In real implementation, would extract and resample to tile_size

        // Placeholder: just create empty file
        std::fs::write(path, &[])?;

        Ok(())
    }

    /// Get file extension for format
    fn get_extension(&self) -> &str {
        match self.format {
            TileFormat::Png => "png",
            TileFormat::Jpeg => "jpg",
            TileFormat::WebP => "webp",
        }
    }

    /// Generate TileJSON metadata
    pub fn generate_tilejson(
        &self,
        info: &TilePyramidInfo,
        bounds: [f64; 4],
        center: [f64; 3],
    ) -> String {
        serde_json::json!({
            "tilejson": "2.2.0",
            "name": "Meridian Tiles",
            "description": "Generated by Meridian GIS",
            "version": "1.0.0",
            "scheme": "xyz",
            "tiles": [
                format!("{{z}}/{{y}}/{{x}}.{}", self.get_extension())
            ],
            "minzoom": info.min_zoom,
            "maxzoom": info.max_zoom,
            "bounds": bounds,
            "center": center,
        })
        .to_string()
    }
}

/// Tile pyramid information
#[derive(Debug, Clone)]
pub struct TilePyramidInfo {
    /// Minimum zoom level
    pub min_zoom: u8,
    /// Maximum zoom level
    pub max_zoom: u8,
    /// Tile size
    pub tile_size: u32,
    /// Total number of tiles
    pub total_tiles: usize,
    /// Tile format
    pub format: TileFormat,
}

/// TMS (Tile Map Service) tile calculator
pub struct TmsCalculator;

impl TmsCalculator {
    /// Calculate tile coordinates for a geographic point
    pub fn lonlat_to_tile(lon: f64, lat: f64, zoom: u8) -> (u32, u32) {
        let n = 2f64.powi(zoom as i32);
        let x = ((lon + 180.0) / 360.0 * n).floor() as u32;
        let y = ((1.0 - (lat.to_radians().tan() + 1.0 / lat.to_radians().cos()).ln() / std::f64::consts::PI) / 2.0 * n).floor() as u32;
        (x, y)
    }

    /// Calculate bounding box for a tile
    pub fn tile_to_bbox(x: u32, y: u32, zoom: u8) -> [f64; 4] {
        let n = 2f64.powi(zoom as i32);

        let lon_min = x as f64 / n * 360.0 - 180.0;
        let lon_max = (x + 1) as f64 / n * 360.0 - 180.0;

        let lat_max_rad = ((1.0 - 2.0 * y as f64 / n) * std::f64::consts::PI).sinh().atan();
        let lat_min_rad = ((1.0 - 2.0 * (y + 1) as f64 / n) * std::f64::consts::PI).sinh().atan();

        let lat_max = lat_max_rad.to_degrees();
        let lat_min = lat_min_rad.to_degrees();

        [lon_min, lat_min, lon_max, lat_max]
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_tile_calculator() {
        // Test tile calculation for a known point
        let (x, y) = TmsCalculator::lonlat_to_tile(0.0, 0.0, 0);
        assert_eq!(x, 0);
        assert_eq!(y, 0);

        let (x, y) = TmsCalculator::lonlat_to_tile(-122.4, 37.8, 10);
        assert!(x < 1024);
        assert!(y < 1024);
    }

    #[test]
    fn test_tile_bbox() {
        let bbox = TmsCalculator::tile_to_bbox(0, 0, 0);
        assert_eq!(bbox[0], -180.0); // min_lon
        assert_eq!(bbox[2], 180.0);  // max_lon
    }
}
